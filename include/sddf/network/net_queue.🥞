/*
 * The current Pancake library for working with network queue structures.
 * Due to design differences between regular (e.g. serial) and ethernet queues/buffers,
 * the below functions specifically addresses the network queue variant.
 * WIP; this is subject to future change/refactorings.
 */

/*
typedef struct net_buff_desc {
    /* offset of buffer within buffer memory region or io address of buffer */
    uint64_t io_or_offset;
    /* length of data inside buffer */
    uint64_t len;
} net_buff_desc_t;

typedef struct net_queue {
    /* index to insert at */
    uint64_t tail;
    /* index to remove from */
    uint64_t head;
    /* flag to indicate whether consumer requires signalling */
    uint64_t consumer_signalled;
    /* buffer descripter array */
    net_buff_desc_t buffers[];
} net_queue_t;

typedef struct net_queue_handle {
    /* available buffers */
    net_queue_t *free;
    /* filled buffers */
    net_queue_t *active;
    /* size of the queues */
    uint64_t size;
} net_queue_handle_t;
 */

/*
 * NOTES:
 * Prefer macros over helpers
 * Naming:  'queue' refers to type net_queue_t,
 *          'q_handle'     to type net_queue_handle_t.
 */

/**
 * Get the number of buffers enqueued into a queue.
 *
 * @param queue queue handle for the queue to get the size of.
 *
 * @return number of buffers enqueued into a queue.
 */
#define net_queue_size(res, queue) \
    queue_get_tail(tail, queue) \
    queue_get_head(head, queue) \
    var res = tail - head;


/**
 * Check if the free queue is empty.
 *
 * @param queue queue handle for the free queue to check.
 *
 * @return true indicates the queue is empty, false otherwise.
 */
#define net_queue_empty_free(res, q_handle) \
    var free_queue = q_handle + HANDLE_FREE \
    queue_get_tail(tail, free_queue) \
    queue_get_head(head, free_queue) \
    var res = ((tail - head) == 0);


/**
 * Check if the active queue is empty.
 *
 * @param queue queue handle for the active queue to check.
 *
 * @return true indicates the queue is empty, false otherwise.
 */
#define net_queue_empty_active(res, q_handle) \
    var actv_queue = q_handle + HANDLE_ACTV \
    queue_get_tail(tail, actv_queue) \
    queue_get_head(head, actv_queue) \
    var res = ((tail - head) == 0);


/**
 * Check if the free queue is full.
 *
 * @param queue queue handle t for the free queue to check.
 *
 * @return true indicates the queue is full, false otherwise.
 */
#define net_queue_full_free(res, q_handle) \
    var free_queue = q_handle + HANDLE_FREE \
    queue_get_tail(tail, free_queue) \
    queue_get_head(head, free_queue) \
    var res = ((tail + 1 - head) == size);


/**
 * Check if the active queue is full.
 *
 * @param queue queue handle for the active queue to check.
 *
 * @return true indicates the queue is full, false otherwise.
 */
#define net_queue_full_active(res, q_handle) \
    var actv_queue = q_handle + HANDLE_ACTV \
    queue_get_tail(tail, actv_queue) \
    queue_get_head(head, actv_queue) \
    var res = ((tail + 1 - head) == size);


/**
 * Enqueue an element into a free queue.
 *
 * @param queue queue to enqueue into.
 * @param buffer buffer descriptor for buffer to be enqueued.
 *
 * @return -1 when queue is full, 0 on success.
 */
/* TODO: check param; assuming nbdt is pointer to buffer desc. */
fun net_enqueue_free(1 q_handle, 1 nbdt) {
    net_queue_full_free(full, q_handle);
    if (full) {
        return -1;
    }
    
    /* q_handle->free */
    var free_queue = q_handle + HANDLE_FREE;
    queue_get_tail(tail, free_queue);
    q_handle_get_size(size, q_handle);
    var n = 0;
    n = pnk_modulo(tail, size);

    var buff_io_offset = 0;
    var buff_len = 0;
    !ldw buff_io_offset, nbdt;
    !ldw buff_len, nbdt + WORD_SIZE;

    /* free_queue->buffers[tail % size] = *nbdt; */
    queue_set_nth_buffer(buff_io_offset, buff_len, n, free_queue);

/* TODO: #ifdef CONFIG_ENABLE_SMP_SUPPORT */
    THREAD_MEMORY_RELEASE();

    /* q_handle->free->tail++; */
    tail = tail + 1;
    queue_set_tail(tail, free_queue);

    return 0;
}


/**
 * Enqueue an element into an active queue.
 *
 * @param queue queue to enqueue into.
 * @param buffer buffer descriptor for buffer to be enqueued.
 *
 * @return -1 when queue is full, 0 on success.
 */
fun net_enqueue_active(1 q_handle, 1 nbdt) {
    net_queue_full_active(full, q_handle);
    if (full) {
        return -1;
    }
    
    /* q_handle->active */
    var active_queue = q_handle + HANDLE_ACTV;
    queue_get_tail(tail, active_queue);
    q_handle_get_size(size, q_handle);
    var n = 0;
    n = pnk_modulo(tail, size);

    /* buff_io_offset = nbdt->io_offset; buff_len = nbdt->len; */
    var buff_io_offset = 0;
    var buff_len = 0;
    !ldw buff_io_offset, nbdt;
    !ldw buff_len, nbdt + WORD_SIZE;

    /* active_queue->buffers[tail % size] = *nbdt; */
    queue_set_nth_buffer(buff_io_offset, buff_len, n, active_queue);

/* TODO: #ifdef CONFIG_ENABLE_SMP_SUPPORT */
    THREAD_MEMORY_RELEASE();

    /* q_handle->active->tail++; */
    tail = tail + 1;
    queue_set_tail(tail, active_queue);

    return 0;
}


/**
 * Dequeue an element from the free queue.
 *
 * @param queue queue handle to dequeue from.
 * @param buffer pointer to buffer descriptor for buffer to be dequeued.
 *
 * @return -1 when queue is empty, 0 on success.
 */
/* NOTE: nbdt is originally a pointer here */
fun net_dequeue_free(1 q_handle, 1 nbdt) {
    net_queue_empty_free(empty, q_handle);
    if (empty) {
        return -1;
    }
    
    /* q_handle->free */
    var free_queue = q_handle + HANDLE_FREE;
    queue_get_head(head, free_queue);
    q_handle_get_size(size, q_handle);
    var n = 0;
    n = pnk_modulo(head, size);

    /* *nbdt = free_queue->buffers[head % size]; */
    queue_get_nth_buffer(buff_io_offset, buff_len, n, free_queue);
    !stw buff_io_offset, nbdt;
    !stw buff_len, nbdt + WORD_SIZE;

/* TODO: #ifdef CONFIG_ENABLE_SMP_SUPPORT */
    THREAD_MEMORY_RELEASE();

    /* q_handle->free->head++; */
    head = head + 1;
    queue_set_head(head, free_queue);

    return 0;
}


/**
 * Dequeue an element from the active queue.
 *
 * @param queue queue handle to dequeue from.
 * @param buffer pointer to buffer descriptor for buffer to be dequeued.
 *
 * @return -1 when queue is empty, 0 on success.
 */
/* NOTE: nbdt is originally a pointer here */
fun net_dequeue_active(1 q_handle, 1 nbdt) {
    net_queue_empty_active(empty, q_handle);
    if (empty) {
        return -1;
    }
    
    /* q_handle->active */
    var active_queue = q_handle + HANDLE_ACTV;
    queue_get_head(head, active_queue);
    q_handle_get_size(size, q_handle);
    var n = 0;
    n = pnk_modulo(head, size);

    /* *nbdt = active_queue->buffers[head % size]; */
    queue_get_nth_buffer(buff_io_offset, buff_len, n, active_queue);
    !stw buff_io_offset, nbdt;
    !stw buff_len, nbdt + WORD_SIZE;

/* TODO: #ifdef CONFIG_ENABLE_SMP_SUPPORT */
    THREAD_MEMORY_RELEASE();

    /* q_handle->active->head++; */
    head = head + 1;
    queue_set_head(head, active_queue);

    return 0;
}


/**
 * Initialise the shared queue.
 *
 * @param queue queue handle to use.
 * @param free pointer to free queue in shared memory.
 * @param active pointer to active queue in shared memory.
 * @param size size of the free and active queues.
 */
#define net_queue_init(q_handle, free, active, size) \
    !stw free, q_handle + HANDLE_FREE \
    !stw active, q_handle + HANDLE_ACTV \
    !stw size, q_handle + HANDLE_SIZE;


/**
 * Initialise the free queue by filling with all free buffers.
 *
 * @param queue queue handle to use.
 * @param base_addr start of the memory region the offsets are applied to (only used between virt and driver)
 */
fun net_buffers_init(1 q_handle, 1 base_addr) {
    q_handle_get_size(size, q_handle);
    var zero = 0;
    var err = 0;
    var cnt = base_addr;

    while (cnt < size - 1) {
        !stw zero, cnt;
        !stw zero, cnt + WORD_SIZE;

        err = net_enqueue_free(q_handle, cnt);
        /* TODO: check */
        ASSERT(!err);
        cnt = cnt + QUEUE_BUFF_SZ;
    }
}


/**
 * Indicate to producer of the free queue that consumer requires signalling.
 *
 * @param queue queue handle of free queue that requires signalling upon enqueuing.
 */
/* TODO: #ifdef CONFIG_ENABLE_SMP_SUPPORT check */
#define net_request_signal_free(q_handle) \
    var free_queue = q_handle + HANDLE_FREE \
    queue_set0_consumer_signalled(free_queue) \
    THREAD_MEMORY_RELEASE();


/**
 * Indicate to producer of the active queue that consumer requires signalling.
 *
 * @param queue queue handle of active queue that requires signalling upon enqueuing.
 */
#define net_request_signal_active(q_handle) \
    var active_queue = q_handle + HANDLE_ACTV \
    queue_set0_consumer_signalled(active_queue) \
    THREAD_MEMORY_RELEASE();


/**
 * Indicate to producer of the free queue that consumer has been signalled.
 *
 * @param queue queue handle of the free queue that has been signalled.
 */
#define net_cancel_signal_free(q_handle) \
    var free_queue = q_handle + HANDLE_FREE \
    queue_set1_consumer_signalled(free_queue) \
    THREAD_MEMORY_RELEASE();


/**
 * Indicate to producer of the active queue that consumer has been signalled.
 *
 * @param queue queue handle of the active queue that has been signalled.
 */
#define net_cancel_signal_active(q_handle) \
    var active_queue = q_handle + HANDLE_ACTV \
    queue_set1_consumer_signalled(active_queue) \
    THREAD_MEMORY_RELEASE();


/**
 * Consumer of the free queue requires signalling.
 *
 * @param queue queue handle of the free queue to check.
 */
#define net_require_signal_free(res, q_handle) \
    var free_queue = q_handle + HANDLE_FREE \
    queue_get_consumer_signalled(signalled, free_queue) \
    var res = (signalled == 0);


/**
 * Consumer of the active queue requires signalling.
 *
 * @param queue queue handle of the active queue to check.
 */
#define net_require_signal_active(res, q_handle) \
    var active_queue = q_handle + HANDLE_ACTV \
    queue_get_consumer_signalled(signalled, active_queue) \
    var res = (signalled == 0);


/////////////////////////////////
/* Helper macros and functions */
/* WORD_SIZE = 8 in util.pnk */

/* Offsets for net_queue_t fields */
#define QUEUE_TAIL 0
#define QUEUE_HEAD WORD_SIZE
#define QUEUE_CSIG WORD_SIZE * 2
#define QUEUE_BUFF WORD_SIZE * 3
#define QUEUE_BUFF_SZ WORD_SIZE * 2

/* Offsets for net_queue_handle_t fields */
#define HANDLE_FREE 0
#define HANDLE_ACTV WORD_SIZE
#define HANDLE_SIZE WORD_SIZE * 2

/* queue getters */
#define queue_get_tail(tail, queue) \
    var tail = 0 \
    !ldw tail, queue + QUEUE_TAIL;

#define queue_get_head(head, queue) \
    var head = 0 \
    !ldw head, queue + QUEUE_HEAD;

#define queue_get_consumer_signalled(signalled, queue) \
    var signalled = 0 \
    !ldw signalled, queue + QUEUE_CSIG;

#define queue_get_nth_buffer(buff_io_offset, buff_len, n, queue) \
    var buff_io_offset = 0 \
    var buff_len = 0 \
    !ldw buff_io_offset, queue + QUEUE_BUFF + QUEUE_BUFF_SZ * n \
    !ldw buff_len, queue + QUEUE_BUFF + QUEUE_BUFF_SZ * n + WORD_SIZE;

/* queue setters */
#define queue_set_tail(tail, queue) \
    !stw tail, queue + QUEUE_TAIL;

#define queue_set_head(head, queue) \
    !stw head, queue + QUEUE_HEAD;

#define queue_set1_consumer_signalled(queue) \
    var set1 = 1 \
    !stw set1, queue + QUEUE_CSIG;

#define queue_set0_consumer_signalled(queue) \
    var set0 = 0 \
    !stw set0, queue + QUEUE_CSIG;

#define queue_set_nth_buffer(buff_io_offset, buff_len, n, queue) \
    !stw buff_io_offset, queue + QUEUE_BUFF + QUEUE_BUFF_SZ * n \
    !stw buff_len, queue + QUEUE_BUFF + QUEUE_BUFF_SZ * n + WORD_SIZE;

/* q_handle getters */
#define q_handle_get_size(size, q_handle) \
    var size = 0 \
    !ldw size, q_handle + HANDLE_SIZE;